What you see on the screen now is something that I just never do. I never rely solely on Selenium or playwright in its entirety to pull text out of pages that I'm trying to get data from. And there's a good reason for that. If we look at this code, you'll see that we are now opening a Firefox browser with Selenium, grabbing some data, and we're going to just print out the text. In this case, we'll see this text come up on the screen in just a minute. But let me ask you this. What happens if, for whatever reason you needed to change this from Selenium to playwright? This whole section here is going to need reworking. However, if we were to write this initial part separately, differently, we could easily just drop in and out whatever part we needed. Now, this is what it comes down to. If you think about extract, transform, and load, which is a common practice in the computing world, you take data from somewhere, you do something with it, you transform it, and then you send it on somewhere else. Should sound familiar, but what if we were then relying on this one single program to do all three, one single package? We're going to have a bad time if we need to change anything. That is why, regardless of the fact that Selenium and playwright can do this, I never do it. I always get them to give me the HTML from the page that they're loading and I send it into my parser. I'll show you what I mean. So let's comment this out for now. That will do. And we'll add in our parser. So we'll do from selectolax parser, we're going to import in our HTML parser class that we can work with. Now, instead of doing this in Selenium, we're now just going to give the parser the page source. So I'll say our HTML is equal to the HTML parser class with our driver page source here. So this driver page source, this is the source of the current page. So this is everything. All the HTML that we're looking for from here. We can simply do the same thing as this elements, but we're going to use our selectolax to pass it. So we'll do elements is equal to HTML CSS because we want to find all of these and we'll just say article like we did up before. Article like this. This is going to give us a list of all the article elements. Then we can do for e in e in elements we'll do print e text I think should work. Let's run now. And we should see hopefully the same thing, the same information coming back that we did before. Okay, so I haven't quite got this right. We got the method. So now we should see the actual text rather than the about method. There we go. So we do have this. We do need to put in strip is equal to true because of the way that this parser works. It's giving us all of the text and all of the elements including all the blank lines. Whereas with Selenium there, I just canceled that, that was running was with Selenium here we were doing that automatically by the looks of it. So let's just double check. We are getting the same thing. So it just looks a bit different because of the way it's being displayed in the terminal. This is the same information. Now by doing it this way, we now open up our options to change the way that we do everything. So I'm going to sort of split this code up a little bit first so we can kind of see how we can construct this. I'm going to say this one, we're going to call it extract. So it's nice and obvious what this code does and we will indent here and here like so. And from here we're going to then return our HTML as this. Then we can close our driver close here. So this will allow us to return the HTML like this. We're going to remove this and we're going to then have a new function and we're just going to call this one pass and this is going to take in some HTML. It doesn't matter if for this function where this HTML is coming from, all that matters is that it is indeed HTML or something like that we can put into our HTML parser class. And yes, I'm going to do this the long way around because I was talking not really thinking and not really worrying about what I was doing. So let's remove this because this is going to come from h elsewhere save and I'm going to remove this. We'll have a main function now, so we'll have a main and this will basically allow us to run everything. So we'll do extract and then we'll do pass on the HTML and then we'll just have our if main is equal to main. So if we call this script directly we get the same thing. So now you can see by simply by I'm going to format this with black when I can remember percent. There we go, tidied up. So now when we run this we could then easily if we needed to create a new function that does extract but with requests. So let's make sure that this still works properly how we're expecting it. We are starting up a browser, it's just hidden on the other screen. I haven't actually done it headless in this case so that does work. So let's say now that Selenium no longer works for us and we want to use requests instead. So we'll do import requests and now we can have a new function that we'll use and we'll call this one extract and requests like this. So now we'll have our response is equal to requests get and I'm hard coding the HTT I'm hard coding the URL here, which not the greatest idea, but this is just a demonstration to go so you understand two scrape.com, and then we can return our response text like this. There we go. So what happens now is if we go ahead and say, well, we don't want to run this through Selenium, we want to run this through our request function instead, we should hopefully get exactly the same thing back. Again, it looks slightly different because of the way the characters are being handled, but you get the idea. Now, where is this not going to be useful? Well, obviously, you need to use these handling of the elements. If, of course, you are doing something like clicking or sending keys, you need to do that through Driver and you need to find the elements to do so. So that would definitely be a case where you'd want to do that. However, I'd always recommend that unless you're just writing something to actually grab a little bit of information, that you still do your click and whatever you need to do up here, and then get the HTML from the page source of that page and send it back to a parser. Because, again, hey, if we needed to change this to Playwright, we can do that. We can totally do that here by installing playwright instead and just changing this function or adding a new one in to that. And our pass function then stays the same. So that's why I do it this way, not just because I want to add some extra steps. If you've enjoyed this video, I think you're going to like this one here, where we use more Selenium but to intercept network requests. Bye.