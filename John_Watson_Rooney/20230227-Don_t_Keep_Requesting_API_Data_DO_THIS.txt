 Cashing is useful for lots of different things. In this video, I'm going to show you how we can store API responses on hand quickly and easily so we don't have to make the same call multiple times. I'll show you two methods how to do it and at the end we're going to put it into a fast API application so you can see how you can really get the benefits from it. So I have a basic example up on the screen here. So we are importing in requests and rich print which is great for printing stuff out if you haven't tried it before, give it a go. We have our request down here. Now it's worth noting that we are calling this API with the character ID that we're going to give it and we're going to just print that data out here. I have the hook put into the response so you can see that every time we make a request using this session, it's going to print out the URL and then down here I'm basically just asking for the same information twice so when I add in the cache and you'll see the difference here. So let's run this one. You can see that we have two sets of data here both the same obviously made the same request and you can see we've got the URL both times and that's telling me that we are making a request that URL both times. So let's add in the first cache that we're going to try. So we'll do from its functools and we're going to import in cache. So the way that this cache works is that we use it as a decorator so we can just decorate our function with the @ cache here. What this is going to do is it's actually going to store whatever comes out of this function in the temporary cache that we can then call it back from that place there. So I'm going to save again and we'll run it again here and you'll see that the second time round after that pause from the time.sleep we don't have that URL paste it that URL printed out from our hook which means that this information here this response came from the cache. Now this sort of cache from functools is much better at storing things like complicated or more expensive function calls that are not so much for actually API requests. Now that's where the next one comes in that we want to talk about which is the request cache. So this video is sponsored by IP Royal. So if you're asking me what the hardest part of web scraping is the first thing I'm going to tell you is it's going to be scaling up your web scrapers but fortunately you can check out the proxies from IP Royal that's going to help you out with that a lot. You can have data center proxies which are just great for massive throughput or the ones that I use which are the Royal residential proxies that are 100% genuine residential IPs from across the globe. These are the best ones for scraping data. You can easily put them into new and existing projects. It's just one line of text that needs to go into your request. You can choose which countries you want to include and exclude and they will auto rotate for you making it super easy. There's also unlimited concurrent requests as well so async is absolutely not a problem. If you're interested in this go ahead and check out the link in the description below and also use my code JWR30 for 30% off your first Royal residential proxy order. Link in the description my code is JWR30. So request cache is a separate package that basically adds on to the requests that we know and love and gives us access to this cached session thing here. What this does for us is it gives us the opportunity to actually create a cache session and specify a backend and if you see down here in this instance I'm using SQ Lite and it's going to store all of these responses in that database for us and then we can call them back when we make this call again. So what this means is we can just use this session here as we would a normal request session make all of our requests and it's going to store the response from that request in the cache. So if we make a duplicate one like we did in the last script there you'll see that it actually comes from the cache rather than the API itself saving us calls making our lives are not quicker and easier. You'll notice here that I'm printing out some information too. When we use the cache session we also have the option to print out the response whether it was from the cache when it was created and when it expires. This information comes from generally the cached headers so when you make this request the response has headers and this will come from there generally speaking. It also gives you an option to say how long you want things to expire with this expire after. Now this won't really work in this because it's obviously only goes for the length of time that the code is running. So I'll you'll notice I've put one in here and a time.sleep here and then removing all the expired responses so you'll see that come through. But let's have a go and let's run this now and we'll see what we get to. So the first thing that I'm going to do is we're going to leave our cache session here and we will ask for these and then we'll see which URL's are cached. What I'm going to do though is I'm going to actually comment out these lines here. We'll print out these ones and we'll leave the what's this one URLs in the cache there. So we'll do that first so let's go ahead and clear this up and run python3 and this one is called cache test. That request there we go. Got it. So let's have a look and see what's happened here. So we have made three requests and you can see we have false none none false and this is this information here response from cache created etc etc. So from cache and the first one is none. That it's none again and now here you can see we've asked for number 46 again. So this is the same this same request and we have a true. So this request came from the cache which means we didn't actually make another request to the API to get the same data back. It's stored it for us. We can see the expires from and everything down here. Then you can see that we have specific URL data saved in the cache. So we know that the cached data that comes back from these specific URLs is stored. So this is particularly useful when you're making requests via an to an API or maybe you're putting some data down from the web somewhere because it will store the information for us, meaning much less requests. So let's go ahead and add back in these here. So we'll be able to remove the expired responses and now note this is going to test the expire after. That's why I have expired after one second by have time.sleep.2 here. So we'll see what happens now. So we can see there's our request for true. This one was in the cache. This one was in the cache because we ran it already. So these ones are stored. So these ones were stored in the cache. So we didn't actually make any responses here. These two were stored. And now because we ran this clear cache remove expired responses because we set them to expire after one second, we got clear our cache there. So hopefully you can kind of get how this works. Now the most common way that you're going to see this is in an application. So you're going to think that perhaps you are running an application that allows your users to input some information like what we were just doing. And then actually create responses, create API requests to an external API or your database, you can then cache to make it accessible much quicker and have less outgoing. So what I've got here is a simple script. I'll just run it first. It's probably easier that way. And let me grab my browser. So we can see we have a simple form and you put in the character ID and you get the name back under here. Some top class web design there. So we can have a look and you can see that I've already got a load of cache URLs. That means all of this data from this API is stored in my cache. So I'm going to go ahead and close off my server here. Okay, so I've deleted our cache. Let's have a quick look at what's actually happening now that you've seen the end response. So Instead of using the session cache like we did in the last one, we want to have a kind of global all around cache. And that's done by using what they call patching and basically just saying use this cache for every request we're going to make. So this was our main page template. And here is our post request. And this is where we put in the information to post back. So we've got a form and it's going to send data to the same API, the same same, you are out that we were looking at in our other pieces of code. And then we have our what's in the cache and then our response. So now that I've deleted the actual cache itself, let's run this again and then start making some more requests. So let's go for no the idea of one, two and three. So let's go ahead and make one again and then come back to our code. You can see that we now have the cache URL showing here as one, two, and three. This means that now whenever we make a request that's going to have this idea and again, instead of querying the server, the API, we're going to use the data that's cached in our database. Now I didn't set this to expire in any way, you probably would want to play with that. And also, if you're doing caching will sound like this for your actual application, you're probably going to want to look into using Redis, which is going to give you a much quicker up to date store. And also, you can look at caching your own more complicated database queries in that. So when your users make that request again, you've got that data on hand and you don't have to go ahead and query your database. So hopefully you guys have got a better understanding now of how caching can work, how you might want to use it for making requests to APIs or put it in your applications. So thank you very much for watching. If you've enjoyed this video, I think you're gonna like this one here too.
