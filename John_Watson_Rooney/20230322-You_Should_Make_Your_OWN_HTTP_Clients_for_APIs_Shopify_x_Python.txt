 In this video, we're going to take this code here that's calling the Shopify API and we're going to create our own HTTP client. We're going to make it better. We're going to create a client that we can reuse to call it. We're going to have a base URL. We're going to have all the right headers being sent and sent in every request. And it's also going to allow us to manage the Shopify Rate Limit much easier. So let's just have a quick look at what this does to start with. So we have our access token here. This is set as a header and we send it with every request. This is a test store, this is a test token, so don't even try. It will be deactivated. Now, when we make a request, we need to send this header along with it. And when we send this header, we actually get some response headers, these ones down here. And as you can see, we have this call limit left. Now Shopify works on a leaky bucket algorithm, which means we have 40 calls per minute, and we get in two back every second, every two seconds, every second. Anyway, what it does is it will tell us if we reach it by saying we have a retry after header. Now, this can get really messy if we start having to repeat a load of this code every time we want to make a request. And every time we make a request, we have to use this long URL here. Now, this will apply to any API that you're calling or any kind of website that you're getting data from that you need to be persistent with your headers or something like that. Now, the first thing I will always tell people is to use a session as much at any time you're doing something like this, always use a session object. It has so many benefits to it. We can go one step further and we can look at sub-classing and inheriting from the request session class and customizing it to our liking. So let's go ahead and create a new file. We'll call this one client. We'll call this one Shopify client.py. We enter. I'm going to go in and I'm going to go rid of that. We don't need it. So the first thing we're going to need to do, I'll make this code a little bit bigger actually. There we go. So we're going to import in the requests package. We're also going to do from Rich. We're going to import print. This is entirely optional. I just like using Rich because it makes things print out much easier for zero effort. Now, another thing we're going to use is I'm going to use the URL join from URLlib.pass. This is just a better way and more controlled way of adding two parts of a URL together. So we'll do from URL from please from URLlib.pass. We're going to import in URL join. Okay. So to start sub-classing this app, we need to create our own class to start with. Now, I'm going to call this client because this is going to be our Shopify HTTP client. And the thing about this is obviously we can instantiate this class in any of our files within our project. So I'm going to make it a lot easier if you're doing a larger project along this lines. So now to actually inherit from this class to sub-class out, we need to do request.session in here. So we need to initialize it. So I'm going to do def init and I'm going to say we have ourself. So this super here with the init basically means that we are now able to have everything that the request session main class is going to have. And it's going to initialize that for us when we do it. If we don't do this, we don't pull in that extra information from that parent class there. But we are going to give it some more info here. So just like a normal class. So we're going to say we're going to pass in a token and a store. Now under here we're going to say ourself.store is equal to the store and self.token, which is the access key. It's going to be equal to the token. So all we're doing is we're just extending the initialization for our version, our subclass of the request session. Whereas this super init is going to give us everything else from the session. So now I want to create a base URL. But I'm going to send with every request. So we don't have to keep doing all of this stuff here every time we want to do something else and a request. So I'm going to say ourself.base URL is going to be equal to. I'm going to go ahead and just grab this from here and put this in here. And I'm going to make this an f string. So we can put the store information in here. So f will get rid of my test store and we'll put it in hereself.store. So we're starting to construct our base URL. Now we want to add the headers to this. So the header we want to send every time is that access token. So we'll do self.headers.update. Now because we are inheriting from the session class, we can just do this exactly like you would do if you had your own session object, which is where this is so useful. So I'm going to grab this paste here. Oh, I'll go outside my brackets. No problem. There we go. So I'm going to save this and I'm going to format with black just to make that a bit neater. So now we have the basis of our extra information that we're going to initialize our client with. Now we want to think about how we're going to manage the rate limit that we get back. Now with this API and a lot of other ones, you get sent your rate left or the amount of calls left you have and a time period until they refresh. And that comes back in the response header. So what we can do is we can create a hook using the request session hooks and actually monitor that response back. So every time we get a response, we can check how many API calls we have left and we can use that to determine whether we need to wait before we send the next one. So I'm going to create a new function. I'm going to call this rate hook like this. We need to have the after the response and we also need to do star arcs and star star keyword arcs just so this works in case you have anything going on here. So as I went through as I showed you in this one here, what we're doing is we're just basically checking if this key exists in the headers and then we're printing out the rate limit that we have. Normally I would suggest logging this, but I'm going to keep it as a print statement so we can see what's going on. And then we're going to check to see if we have this retry after. Now, into the documentation and we only get this retry after header if we have hit the maximum requests and we also get this 429 status code. So this part is not necessary but handy to have and this part is useful and it's going to let us work with this. So what I'm going to do is I'm going to copy all of this down here. Let's get that properly indented and then we're going to add it into our session so we can do self dot hooks because this is a session object. Do this on the response. Let's put this in the middle of the screen and dot append to add a new hook and we only have one so we can just do right hook here like this. So every time we have a response, we're going to call this right hook and it's going to check for us and sleep if we need to. So we're almost done so all we're basically doing is overriding some some basic information but as you'll know we've got this base URL we need to do something with. Now to add this to every request we actually need to modify the request method on the client session on the request session. Now to do that we can go ahead and create a new method on our class and we're going to call this one request because that's what it is. Now you'll see my code has been trying to give me all of this stuff here. We don't actually need all of that. We just need a few special ones. We need self. We need method the URL that we're going to be making and we can just pass in star arcs and star star clogs and that will work. Now because we want to amend this session this request session class method we're going to need to return super again. So the super is going to let us modify this method this class method and we can then do request and we'll say we want to return the method which is going to be the get or post or whether. Now we're going to use our URL join and we give that to arguments the first one is going to be self dot base URL and then the second one is the URL that we're going to give it when we actually access this method when we use it in our code. Then we just pass in our arguments and our keyword arguments in case there were any in that respect. So this is quickly recap what we've done we're creating a new class which is going to inherit it's going to subclass the request session object the request session class. When we initialize that we also need to use super in it which is going to initialize the parent class that's going to give us access to everything that we need. We're taking in a couple of pieces of information in which we're going to then use to construct our base URL and our access token. Now obviously if you were doing this for real you're going to pull your access token from an in from an environmental variable rather than in the code like this and it should be self dot token. There we go. I was missing something the next thing that we've got is the managing the rates which basically is going to come down to if we get stuck and we made too many requests. We're going to wait the amount of time that the API is telling us that we should wait before we make an extra quest simply by sleeping. Now this is a bit messy because I've got in float because this headers here is a string which is a string 2.0 so we turn it into a float to turn it into an in bit messy. Then we apply the hook. We're then modifying the actual request method. The main thing we're doing here is we're saying hey when we actually call this we're going to add in this base URL every time like this. So let's try it so let's go ahead and create a we'll just do if name is equal to main so it's a bit tidier and we'll basically just say our client is going to be equal to a client. Now this is going to take in a store which is going to be equal to a string. We use my test store and a token which is going to be equal to the token which I just removed from the code here. We'll just go grab that from here again. There we go. I ended up with one too many quite marks. Let's remove that. Let's put this in the middle of the screen. Great. So let's do our responses equal to client.get and we need to give it the partial URL which I think is going to be products. Again let me just grab this from over here. That would just see this one we'll use this as testing again. Let's do paste that in there. So now let's save and we'll just print out the response.json that we get back from this request and let's try it out there. So I need to activate my virtual environment and we'll do Python 3 subclasses and this was Shopify client.py. There we go. So you can see that our print statement has given us the rate of one of 40 left. That's one of our 40 calls we've just used. And we've got the information back which is the product ID in the name which is what we asked for for this specific information. So if you look how simple this one line here is compared to this one here, you'll see that we basically have now by subclassing the request session. We've made our lives much easier every time we want to make a call to this store. And we made it so that we can use this client on many Shopify stores because we're passing in the store information and the token. Again, get your token from an environment variable and don't do this and this token will not work anymore. So hopefully you have enjoyed this video and kind of understand now how you can subclass different classes to modify the, modify the methods to bend them to how you want them to work. If you've enjoyed this video, I want another one right here which I think you'll like too.
