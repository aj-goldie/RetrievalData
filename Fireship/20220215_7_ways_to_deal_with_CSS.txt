When you get started with web development, they say you gotta learn the CSS fundamentals. I agree, but when you get out into the real world, you'll find that one does not just use plain CSS to build an app. The left side's getting lower than the right side. I can see what's happening now. Twist it. Alright, it's just too painful. There are literally hundreds of libraries that attempt to make CSS better, but so far there's no universal solution. Today we'll take a look at seven different ways to write CSS, specifically in a react app using next JS. But most importantly, we'll look at the trade offs of each approach so you can decide what's best for your project. If you're new here, like and subscribe and check out my full courses on Fireship IO to learn even more by building complete projects. Now let's talk about CSS here I have a pristine next JS app, and the most primitive way to style it is to create global CSS that applies to the entire application. That might work okay for a small application, but it doesn't scale well at all. The first problem you'll run into is that naming things gets really hard because CSS cascades. To address this, you'll likely need to use a naming convention like BeM, but it's not going to be very fun. It's hard to do perfectly, and you'll probably end up using important everywhere, because you've got more important things to do than figure out how to not use important. The other problem is that it generally results in a very large and inefficient CSS bundle. The larger the bundle size, the slower the app loads. Luckily, next JS supports a tool called CSS modules out of the box to address some of these concerns. A CSS module file looks just like regular CSS, but it can be scoped to an individual component, and that means you don't have to worry about name collisions when writing your code. In other words, you can have two different module files that define the same class name, but because they're scoped locally, you don't have to worry about them interfering with each other. In addition, it tells NextJs exactly which CSS to load for a given page, which can reduce the bundle size. Now that may sound inefficient because you may want to share styles between multiple components, but modules have a special composes property that can import and override code from a different module. Overall, modules will make your life much easier, but we're still dealing with plain CSS here, and one thing it lacks is programmatic features like loops, functions, mixins and things like that. The classic way to make CSS better is to use a preprocessor, which allows you to write a different syntax like SAS less or stylus. Then use a compiler to convert that code back into plain CSS. The most popular version is SCSS, which is a superset of plain CSS, allowing you to write regular CSS with additional features on top of it. In next JS, all you have to do is install the SAS compiler, then change the file names in your project. All the compilation will happen in the background for you automatically. And now you can use features like variables, mixins and functions to make your code way more concise and efficient. SAS is great and all, but the problem is that it's an entirely different language to learn and it's completely decoupled from our main application code. We already have our JavaScript and HTML together, why not add our CSS there as well? And that's where your CSS and JS libraries come in. There are many different libraries out there like styled components, emotion, JSS, Styltron and many others, but the characteristic they all share is they allow you to write CSS in your JavaScript code. That allows you to do many of the programmatic things you can do in SAS, but you have the full power of JavaScript at your fingertips. But more importantly, it makes it easy to create dynamic styles based on the state of your application. In next JS there's a homegrown solution called styled JSX. To use it, all you have to do is open up a style tag in a component, use the JSX attribute, then write your CSS as a template literal string. The cool thing about this is that you can now compute or interpolate values directly inside the style, which means you can dynamically change the styles based on state changes to the application. In addition, these styles are scoped to the location where they're defined, which means that like modules, they won't bleed out to affect other styles. That's pretty cool, but we still have one major problem. We need to figure out how to write code that will make the application actually look good. One way to address that is to bring in a utility class library like tailwind or Windy CSS to provide a huge collection of utility classes that can help us rapidly build out a good looking UI. Tailwind is very powerful, but it does require some additional tooling and configuration to get started. Once installed, you'll be able to style your components with utility classes instead of writing the CSS directly. In my experience, this tends to be a much faster way to implement the design you're going for, because all your styles are right at your fingertips with IDE intellisense. In addition, it can purge all of your unused CSS automatically to result in a very efficient bundle size. But not everybody likes the utility class approach because your component HTML code can get out of control very quickly. It is a big commitment, and you'll have to learn how to organize your code properly. The other thing about tailwind is that it doesn't provide pre built components for you, so you still need to do a lot of work on your own. There are other popular CSS frameworks out there, like bootstrap or bulma. What makes it different than tailwind is that it provides pre built components, giving you a solid collection of styles for things like buttons, cards, and so on. To use it in next JS, all you have to do is install it with NPM, then import the bootstrap style sheet from your node modules. It doesn't have the tooling that tailwind does, but to use it, all you have to do is start referencing the classes in your components. It's simple, effective, and has a minimal learning curve. However, if you're only using the bootstrap style sheet, you might find yourself creating your own components to wrap those styles in a way that can be efficiently used with other components, like you might have a bootstrap button component to avoid repeating the same class names over and over again. Another problem is that using bootstrap like this will result in a large bundle size because there are a lot of unused classes that will get included in the final CSS. When it comes to react, a more tightly integrated approach is to use a full blown component library. There are ones that already do that for bootstrap, but the react ecosystem has many other design systems that you'll want to check out. An awesome one I've been using lately is mantine. Not only does it handle much of your CSS, but it provides a ton of utilities to handle things that you would otherwise have to do in JavaScript as well, like hooks to use the intersection observer API to know when an element is visible. It also has tools to manage modals and notifications, calendars, and a ton of other stuff. Now libraries like this tend to be fairly opinionated, so make sure to choose one that you really like. Other ones worth checking out are ant material design, rebase, chakra, and Tomagui. That's not a complete list, so let me know your favorite library in the comments. Congratulations. You now know seven different ways to deal with CSS and react. Keep in mind that you can mix and match all these different techniques to use whatever works best for your application. If you want to learn more advanced concepts with full project courses, become a pro member at Fireship IO. Thanks for watching and I will see you in the next one.