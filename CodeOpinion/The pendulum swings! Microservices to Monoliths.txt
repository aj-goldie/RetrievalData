 Logical boundaries aren't physical boundaries. Welcome back to my channel. I'm Derek Comarten from codepinney.com. In the pendulum, it's swinging again. Over a decade ago, we had a move from monolith to microservices. Now we're swinging in the other direction and either consolidating microservices or moving to a modular monolith. Now this isn't really that surprising because of the confusion that a physical boundary and a logical boundary were pretty much the same thing, which they're not. And if you make this distinction, it opens up a lot of possibilities. Let me explain. This video is brought to you by Event StoreDB. The stream database built from the ground up for event sourcing, CQRS, and Event Server Microservices. For more on Event StoreDB, check out the link in the description. One of the good things that came from microservices is simply the idea of defining boundaries. Finally, where Adrien Cockroft define what a microservice is, is a loosely coupled service oriented architecture with bounded context, bounded context coming from domain driven design. How I like to define it, not really the micro part, but just the service, is to see authority of a set of business capabilities. So again, defining boundaries. What does a service do? What business capabilities does it provide? At least we got to the point where we were defining boundaries. All right, great. We're defining boundaries. But what type of boundaries? What I've been really alluding to are logical boundaries. However, microservices, as most interpreted, defined as also being physical boundaries. In this self-forcing that idea can have a lot of issues. So we have a logical boundary, and oftentimes that was also turning into an individual source repo. Let's say our Git repo. So we had a logical boundary, and we had exactly for that, we had some repository, and then we turned that source code into some deployment artifact. This could be a process, a container, etc. But all of a sudden we had a one to one to one. We defined some logical boundary that we wrote code for, separately in its own repository, and then built that and turned it into some deployment artifact. Now you may be thinking, well, that's not exactly it, because we use a monorepo. Okay, fair enough, you have multiple different logical boundaries, these services. They all live within the same monorepo, the same source repository, but you're still building those logical boundaries into some physical deploy and little unit, let's say a container. Now let's say we have three logical boundaries, and they're all communicating and coupled in some way to each other. If we were within a monolith, this would likely all be in a single process. So all this communication done in process. But because we moved to microservices, and our logical boundaries are physical boundaries, now we've introduced network calls. And now everything is done as a network call, likely RPC rather than in process. What could go wrong? To answer that question, I recommend checking out the fallacies and distributed computing as it's still very relevant. And if you're in this trivia environment, like microservices, you're probably well aware and familiar with the issues that you face, such as network reliability, timeouts, latency, and many more. So I mean when I'm talking about logical versus physical boundaries, let's say I have three physical boundaries here. We have a front end, this could be a web app, or some mobile app, and it's communicating with a backend that could be an HTTP API. And of course we have databases, caches, things like that, and other infrastructure concerns. So these are three physical boundaries, but that doesn't necessarily mean that they're logical boundaries. Because if we're thinking vertically, we could have just a slice of this that exists, that's a logical boundary that contains front end, back end, and the database, and infrastructure related to those concerns that are in that logical boundary. Again, I was defining it as a set of business capabilities, the authority. What's in that slice is the authority of those business concerns throughout those physical aspects. That means there's different ways of thinking of our system. And this is a diagram of the 4+1 architectural view model, and I really am going to harp on here is the logical view in the physical view, but the development view it has I was mentioning of our source repo. So if we had a logical view like I was defining for that had its own development view, that its own source repo, and we were turning that into some deployment artifact, we were creating a one to one to one between logical development and physical. Yes, you could be using a mono repo, but if you're taking a logical view, some logical aspect of that, and turning into that as a deployment concern, some deployable unit, you're immediately equating them a logical and physical to being one to one, but they don't have to be. This means that you can define logical boundaries. Again, what are the capabilities of that service? What does it do? We can define that it could be in a mono repo, but then that all those different logical boundaries are then composed together into a single process, into a single deployable unit. So using that as an example, if we went from thinking about physical boundaries and logical boundaries have to be a one to one, and they don't now we're composing things together. Now what we have is a single process, a single executable that's running, let's say a container, and then now these aren't RPC network calls anymore. These are all done in process. Now I'm not suggesting this is what you should be doing is composing all your different logical boundaries into a single deployable unit. I'm simply illustrating that they don't have to be a one to one. You have many different options of possibilities when you start realizing they can be different things as an example. You could have a one logical boundary that's in one source repository, and that may turn into two different physical different containers that have different concerns. Maybe one's an HBAPI, and the other is more of a worker role that's consuming messages from a queue or topic or some type of message broker. Maybe you have a logical service that has two different source repositories. Maybe you have one that's for an H2B H API that's done in one programming language, and you prefer to have a different source repo for whatever reason for maybe you're front end that's done in JavaScript or TypeScript, and those turn into two separate deployable units because the, as I was mentioning before, are different physical aspects. Maybe you have a single logical boundary. Again, multiple different source repositories that again get composed into a single deployable unit. This just gives you a lot of options. When you start thinking about multiple logical boundaries, this means that we have service A, service B, let's say service A has a back end component, and that gets turned into some container, but also has some front end component of that, let's say that's mobile. We have another logical boundary service B, and it's as well being used for mobile. Those two logical boundaries can be composed together, let's say we have some build process that for Android turns it into that APK. Service A, that logical boundary has some functionality that exists within that mobile app, and so does service B, and they're deployed in built together into that APK. So another thing that often becomes a problem when you're conflating and having a one to one between logical and physical, especially when you don't need them to be per se because you don't need that physical independence for scaling or whatever reason is on the back end or related to infrastructure. So as the example here, let's say we have multiple different logical boundaries, and they're all running independently. That's fine. But why do they actually have to have their own physical database? Do they? They could have the same physical database instance, but within that instance have their own separate schemas. This can simplify your deployment process, your infrastructure, costs. Do you need to scale them independently? Could there be noisy neighbors? Again, this is all context specific. But depending on what your context is, again, if you're not confusing logical boundaries and physical boundaries, this is an option. Now, if you go by age against definition of microservices, he mentioned loosely coupled bounded context, so logical boundaries that are loosely coupled. So if we're using an adventure of an architecture or messaging to loosely coupled between these services, that means that what we could be doing is composing all these different logical boundaries into a single deployable unit. We have service A, service B, service C, they're loosely coupled and using messaging, and we're not doing any RPC between them or in process. Now, because we have this set up the way we do and loosely coupled and there isn't any direct communication, we could decide, okay, well, service C needs to scale differently for whatever concerns, physical aspect, we could deploy that separately as its own deployable unit, and we can still compose service A and service B together. Again, it's all about options. Logical boundaries don't have to be a one-to-one with a physical boundary. You could have your logical boundary, which of course could contain UI concerns, your back-end concerns, your data persistence, all with that within a logical boundary, which could be a spread across different physical boundaries, or composed with other logical boundaries and their concerns. It just gives you a lot of options. Once you start thinking about this and you make this distinction, you may start wondering, well, why is this whole thing about microservices and now consolidating them or thinking about modular monoliths? How is this even a thing to begin with if we were just thinking about them separately? Good question. If you think topics like this are interesting, but you have thoughts, questions, or opinions, you can join my channel and get access to a private Discord server where you can chat with other software developers. Check the link in the description on how to join. If you found this video helpful, please give it a thumbs up. If you have any other thoughts or questions, make sure to leave a comment and please subscribe for more videos on software architecture and design. Thanks.
